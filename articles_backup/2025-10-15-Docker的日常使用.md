---
title: "Docker的日常使用"
created_at: "2025-10-15 03:57:29"
updated_at: "2025-10-15 03:57:29"
issue_number: 25
labels: ['docker']
url: https://github.com/syaofox/syaofox.github.io/issues/25
---

# Docker的日常使用

在 Docker 和 Docker Compose 的使用中，理解文件存放位置、缓存机制以及如何管理镜像和容器非常重要。

---

## 一、 Docker 文件存放位置（默认）

Docker 在安装时会在主机上创建一个目录来存储所有数据，包括镜像、容器、卷（Volumes）、网络配置等。默认情况下，这个目录是：

* **Linux:** `/var/lib/docker/`
* **Windows:** 通常在 `C:\ProgramData\Docker\docker` 目录下（或 WSL 2 集成模式下在 WSL 虚拟机内部）
* **macOS:** 在 Docker Desktop 管理的虚拟机/WSL 2 发行版内部（用户通常不需要直接访问这个路径，而是通过 Docker Desktop 界面或命令管理）。

### 关键子目录：

| 子目录 | 存放内容 |
| :--- | :--- |
| **`volumes/`** | Docker **卷（Volumes）** 的实际数据存储位置。这是推荐用于持久化数据的机制。 |
| **`containers/`** | 所有容器的配置、日志和可写层（但通常不直接存储用户数据，除非使用绑定挂载或卷）。 |
| **`image/`** | 存储所有 **镜像层** 的元数据和实际文件。 |
| **`aufs/`, `overlay2/`, `devicemapper/` 等** | 实际的存储驱动（Storage Driver）目录，存放镜像和容器的文件系统层数据。**`overlay2`** 是现代 Linux 发行版中最常用和推荐的驱动。 |

**重要提示：**
* 用户数据的**持久化**应该使用 **卷（Volumes）** 或 **绑定挂载（Bind Mounts）**，不要直接操作 `/var/lib/docker` 目录下的文件。
* 如果磁盘空间不足，可以通过修改 Docker 守护进程的配置（通常是 `/etc/docker/daemon.json`）来更改这个根目录 (`data-root` 字段)，但在操作前务必备份数据。

---

## 二、 镜像和容器的缓存机制

### 1. 镜像（Image）缓存

Docker **镜像** 是由一系列 **只读的层（Layers）** 构成的。这种分层结构是 Docker 缓存的核心：

* **Dockerfile 构建缓存：**
    * 当使用 `docker build` 命令时，Docker 会逐行执行 **`Dockerfile`** 中的指令。
    * 如果某一步骤（例如 `RUN`, `COPY`, `ADD` 等）自上次构建以来没有改变，并且它前面的所有层也没有改变，Docker 就会 **复用** 之前构建好的那一层，而不是重新执行该指令。这大大加快了构建速度。
* **如何利用缓存：**
    * 将 **不常变动** 的指令（如安装依赖）放在 **`Dockerfile`** 的 **前面**。
    * 将 **经常变动** 的指令（如复制应用代码）放在 **后面**。
    * 使用 `docker build --no-cache` 可以强制禁用所有缓存，重新完整构建。

### 2. 容器（Container）的文件系统

* 容器在启动时会在其镜像层之上添加一个 **可写层（Writable Layer）**。
* 容器运行时产生的所有写入、修改和删除操作都只发生在这一可写层中。
* 当容器被删除时，这个可写层也会默认被销毁（除非使用了持久化卷）。
* **缓存/持久化：** 容器内的文件通常不是持久化的。要实现持久化存储（即容器重启或删除后数据仍保留），必须使用 **卷（Volumes）** 或 **绑定挂载（Bind Mounts）**。

---

## 三、 日常管理镜像、容器、卷的命令

日常管理主要依靠一系列 `docker` 命令，`docker compose` 则用于多容器应用的管理。

### 1. 镜像 (Images) 管理

| 命令 | 作用 |
| :--- | :--- |
| `docker pull <image>:<tag>` | 从 Docker Hub 或其他仓库拉取镜像。 |
| `docker images` | 列出本地所有镜像。 |
| `docker build -t <name> .` | 根据当前目录的 `Dockerfile` 构建一个新镜像。 |
| `docker rmi <image_id/name>` | 删除本地一个或多个镜像。 |
| **`docker image prune`** | **清理** 悬挂（dangling，即未被任何标签引用的）镜像。 |
| `docker history <image>` | 查看镜像的构建历史（层信息）。 |

### 2. 容器 (Containers) 管理

| 命令 | 作用 |
| :--- | :--- |
| `docker run -d --name <name> <image>` | 以后台模式运行一个新容器。 |
| `docker ps` | 列出正在运行的容器。 |
| `docker ps -a` | 列出所有容器（包括已停止的）。 |
| `docker start <container_id/name>` | 启动一个已停止的容器。 |
| `docker stop <container_id/name>` | 优雅地停止一个正在运行的容器。 |
| `docker restart <container_id/name>` | 重启容器。 |
| `docker rm <container_id/name>` | 删除一个已停止的容器。 |
| `docker logs <container_id/name>` | 查看容器的日志输出。 |
| `docker exec -it <name> /bin/bash` | 在运行中的容器内执行命令（通常是进入容器）。 |
| **`docker container prune`** | **清理** 所有已停止运行的容器。 |

### 3. 卷 (Volumes) 管理

| 命令 | 作用 |
| :--- | :--- |
| `docker volume create <name>` | 创建一个命名卷。 |
| `docker volume ls` | 列出所有卷。 |
| `docker volume inspect <name>` | 查看卷的详细信息（包括实际存放路径）。 |
| `docker volume rm <name>` | 删除一个卷（只有在没有容器使用时才能删除）。 |
| **`docker volume prune`** | **清理** 所有未被使用的卷。 |

### 4. 系统级清理（重要）

* **`docker system prune`**：这是最常用的清理命令，会删除所有**停止的容器、悬挂的镜像、未使用的网络和悬挂的构建缓存**。
* **`docker system prune -a`**：**极度小心使用！** 除了上面的内容，还会删除所有**未被任何容器使用的镜像**。

---

## 四、 Docker Compose 的文件与管理

### 1. Docker Compose 文件位置

* **`docker-compose.yml`** (或 `docker-compose.yaml`)：
    * 这是 **Docker Compose** 的核心配置文件。
    * 它通常放在项目的 **根目录** 下。
    * Docker Compose 命令（如 `up`, `down`）默认会在当前目录查找这个文件。

### 2. Docker Compose 管理命令

| 命令 | 作用 |
| :--- | :--- |
| `docker compose up -d` | **启动** 应用中的所有服务，并在后台运行（`-d`）。 |
| `docker compose down` | **停止并移除** `up` 命令创建的容器、网络和默认卷。 |
| `docker compose ps` | 列出 Compose 文件中定义的服务（容器）的状态。 |
| `docker compose logs` | 查看所有服务的聚合日志。 |
| `docker compose exec <service> <command>` | 在运行中的服务容器中执行命令。 |
| `docker compose build` | 仅重新构建服务（如果服务定义中有 `build` 关键字）。 |

**注意：**
* 使用 `docker compose down -v` 可以同时移除服务创建的**匿名卷（Anonymous Volumes）**。对于**命名卷（Named Volumes）**，需要手动使用 `docker volume rm` 或 `docker volume prune` 清理。


