---
title: "Git 某个提交的导出与导入"
created_at: "2025-10-22 02:47:52"
updated_at: "2025-10-22 02:47:52"
issue_number: 45
labels: ['tips']
url: https://github.com/syaofox/syaofox.github.io/issues/45
---

# Git 某个提交的导出与导入

## 方法1 使用 `git format-patch` 和 `git am`

使用 **`git format-patch`** 和 **`git am`** 来迁移完整的提交历史

-----

### 步骤一：在源仓库中生成补丁文件

在包含你想要迁移的提交的**源仓库**中执行以下操作。

#### 1\. 确定要导出的提交

你需要知道你想生成 diff 的提交的范围。常见的场景有两种：

  * **只导出某个** **`COMMIT_HASH`** **的修改：**
    使用 `COMMIT_HASH^..COMMIT_HASH`。
  * **导出一个分支** **`FEATURE_BRANCH`** **上，自** **`master`** **分支分叉以来** **所有** **的修改：**
    使用 `master..FEATURE_BRANCH`。

#### 2\. 生成补丁文件

使用 **`git format-patch`** 命令生成补丁文件。这个命令会为范围内的**每个**提交生成一个独立的 `.patch` 文件，并包含作者信息、提交信息和实际的 diff 内容。

**示例（导出单个提交）：**

```bash
git format-patch -1 COMMIT_HASH
```

*（`-1` 表示只生成一个补丁文件，即指定 `COMMIT_HASH` 的那个提交。）*

**示例（导出两个分支之间的所有提交）：**

```bash
git format-patch master..FEATURE_BRANCH
```

**命令执行后：**

你会在当前目录下看到类似这样的文件：

```
0001-Commit-Message-of-the-first-commit.patch
0002-Another-commit-message.patch
...
```

#### 3\. 传输补丁文件

将这些生成的 `.patch` 文件（例如，通过复制、邮件、U盘或网络传输）移动到**目标仓库**所在的机器或目录。

-----

## 步骤二：在目标仓库中应用补丁文件

在你要导入修改的**目标仓库**中执行以下操作。

### 1\. 切换到目标分支

进入目标仓库目录，并确保你处于要应用这些修改的分支上（例如 `master` 或 `develop`）：

```bash
cd /path/to/target/repo
git checkout target_branch
```

#### 2\. 应用补丁文件

使用 **`git am`**（Apply Mailbox）命令来应用补丁。它不仅会应用代码修改，还会尝试**保留原始提交的作者、提交信息和提交时间**。

**应用单个补丁：**

```bash
git am 0001-Commit-Message-of-the-commit.patch
```

**应用所有补丁（推荐）：**

```bash
git am *.patch
```

*（这会按照编号顺序依次应用所有找到的补丁文件。）*

#### 3\. 解决冲突（如果发生）

如果在应用过程中发生**冲突**，`git am` 会暂停。你需要：

1.  手动编辑冲突文件，解决冲突。
2.  使用 `git add <file>` 标记文件为已解决。
3.  使用 `git am --continue` 继续应用补丁。

如果想中止整个应用过程，可以使用 `git am --abort`。

#### 4\. 导入完成

一旦 `git am` 成功完成，这些提交就会带着**完整的历史信息**（包括作者、时间戳、提交信息）作为新的提交添加到你的目标仓库中。

**总结流程：**

1.  **源仓库：** `git format-patch <range>`
2.  **传输：** 复制 `.patch` 文件
3.  **目标仓库：** `git am *.patch`


## 方法2 `git diff` 和 `git apply`


这种方法适用于你只想将代码的最终状态差异应用过去，**不关心**保留原始的作者、时间戳或提交历史的情况。

-----

### 使用 `git diff` 和 `git apply` 导入修改

#### 步骤一：在源仓库中生成纯 diff 文件

在包含你想要迁移的修改的**源仓库**中执行以下操作。

##### 1\. 确定并生成 diff 文件

使用 `git diff` 命令来比较两个引用（例如分支、提交哈希或标签）之间的差异，并将输出重定向到一个文件。

**场景一：生成一个分支（`feature_branch`）相对于另一个分支（`master`）的所有差异**

这是最常见的做法，它将所有提交的代码修改**合并**成一个单一的差异文件。

```bash
# 格式： git diff [基础引用]..[目标引用] > [文件名].diff
git diff master..feature_branch > combined_changes.diff
```

**场景二：只生成某个提交（`COMMIT_HASH`）的代码差异**

```bash
git diff COMMIT_HASH^! > single_commit_change.diff
# 或者使用：git show COMMIT_HASH > single_commit_change.diff
```

##### 2\. 传输 diff 文件

将生成的 `.diff` 文件（例如 `combined_changes.diff`）传输到**目标仓库**所在的目录。

-----

#### 步骤二：在目标仓库中应用 diff 文件

在你要导入修改的**目标仓库**中执行以下操作。

##### 1\. 切换到目标分支

确保你处于要应用这些修改的分支上：

```bash
cd /path/to/target/repo
git checkout target_branch
```

##### 2\. 应用 diff 文件

使用 **`git apply`** 命令来应用 diff 文件。

```bash
git apply combined_changes.diff
```

**注意点：**

  * `git apply` **只会修改你的工作区**（Working Directory）和**暂存区**（Staging Area）。
  * 它**不会**自动创建提交（Commit）。

##### 3\. 检查和提交

应用完成后，所有的代码修改已经反映在你的工作区中。

1.  使用 `git status` 检查哪些文件被修改了。
2.  解决可能出现的冲突（如果 `git apply` 失败，它会提示你手动解决）。
3.  当你对修改满意后，手动创建**一个**新的提交。

<!-- end list -->

```bash
git add .
git commit -m "Imported changes from the source repository via diff"
```

## 总结：`diff`/`apply` 方式的特点

| 优点 | 缺点 |
| :--- | :--- |
| **简单快捷：** 只生成一个文件，操作步骤少。 | **丢失历史：** 所有的修改会被合并成目标仓库中的一个新提交，丢失了原始的提交粒度、作者和时间戳信息。 |
| **纯粹代码：** 只关注代码的增删改，不涉及元数据。 | **手动提交：** 你需要手动编写提交信息，且新提交的作者和时间戳是你（操作者）的。 |
| **灵活应用：** 可以应用于工作区，让你在提交前更容易审查和修改。 | **容易出错：** 对于复杂的历史迁移，难以追踪原始的提交边界。 |

如果你需要保留历史，请使用 **`git format-patch`** 和 **`git am`**；如果你只需要迁移代码内容，且不介意丢失历史，可以使用 **`git diff`** 和 **`git apply`**。

